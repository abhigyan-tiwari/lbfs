
Caching Client Implementation

close-to-open consistency is: on any close, nfs client flushes all
changes to server; on any open, nfs client fetches latest attributes
from server, and loads new data when the cache time is less than
mtime.

consistency
 0) don't update cache if cached file is dirty
 1) if lease has not expired, and cache time matches mtime, use cache
 2) if lease has expired, fetch attribute; if cache time matches
    mtime, use cache
 3) if lease has expired, fetch attribute; if cache time does not
    match mtime, update cache

access
 - on each access, check if cache needs to be updated, if so, mark
   cached file as blocked
 - on any subsequent read/write/setattr RPC to the file, if cached
   file is blocked, RPC is queued
 - after each block received from server, check if any one of the RPC
   can be executed. that is, if the RPC operates on a range of data
   already received from the server
 - can fetch data out of order, in order to satisfy an out of order
   read request immediately
 - when cached file is updated, unqueue and execute each RPC

attributes in attribute cache and file cache
 - if file is cached and dirty
   - return attribute from file cache on GETATTR
   - don't update attribute cache with new attributes from server
   - XXX we don't modify the attribute returned from server on the
         dirty file, such as, for example, ACCESS, should we?

write
 - don't update mtime on each write, because clocks can be out of sync
 - mark cached file dirty on first write, so we won't update the cache
   file on subsequent ACCESS until the cache file is flushed to server
 - update size in both attribute cache and file cache
 - always return FILE_SYNC
 - XXX what verf should we return

close
 - send WRITE with UNSTABLE
 - send COMMIT
 - check wcc after each write/commit. after the last commit, if the
   cached file is not dirty (i.e. has not been writen to since the
   last close), use the last wcc.after as the attribute for the cached
   file.

commit
 - since we return FILE_SYNC on each WRITE RPC, we should not see any
   COMMIT RPCs unless they are for dangling WRITEs. so we just pass
   them onto the server.

setattr
 - if size is changed, update size in both attribute cache and file cache
 - wcc checking is done to update the attribute in the file cache
 - always forward setattr rpc onto the server

wcc
 - wcc checking is done when we flush cached file to server (i.e.
   on write and commit RPCs) and when processing setattr
 - the goal of doing wcc checking is to make the attribute in the file
   cache be the same as the attribute on the server, so after a close,
   another open will not trigger a cache update
 - to make wcc work, "osize" field is kept for each cached object that
   reflects the size of the object on server. as the size of the
   object in cache changes, osize does not change. osize is updated
   when the cached object is updated, flushed, or when setattr is
   processed (since setattr is always forwarded to server)

can we depend on nfs client to always send an ACCESS rpc before any
read? we don't do access control upon seeing a READ rpc: we just
return data from the cached file. if an user cannot access a file, the
ACCESS rpc will fail, and therefore no READ rpcs will be sent.

is it bad to evict from lrucache a file with an user count greater
than zero?

