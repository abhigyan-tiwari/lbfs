
XXX implement wcc
  - on each write/commit, check if wcc.pre == previous attribute of
    file, if so, update attribute, otherwise, don't update

close-to-open consistency is: on any close, nfs client flushes all
changes to server; on any open, nfs client fetches latest attributes
from server, and loads new data when the cache time is less than
mtime.

consistency
 0) don't update cache if cached file is dirty
 1) if lease has not expired, and cache time matches mtime, use cache
 2) if lease has expired, fetch attribute; if cache time matches
    mtime, use cache
 3) if lease has expired, fetch attribute; if cache time does not
    match mtime, update cache

attributes in attribute cache and file cache
 - if file is cached and dirty
   - return attribute from file cache on GETATTR
   - don't update attribute cache with new attributes from server
   - XXX we don't modify the attribute returned from server on the
         dirty file, such as, for example, ACCESS, should we?

write
 - don't update mtime on each write or close. can't update on write
   bcecause clocks can be out of sync; can't update on close because
   we don't know if our writes and commit conflict with another
   client's writes or not
 - mark cached file dirty on first write; we won't update the cache
   file on subsequent ACCESS until the cache file is flushed to server
 - update size in both attribute and file cache
 - always return FILE_SYNC
 - XXX what verf should we return

close
 - send WRITE with UNSTABLE
 - send COMMIT
 - does not update cache file's attribute (i.e. mtime), so the
   subsequent read should trigger a fetch from server

commit
 - since we return FILE_SYNC on each WRITE RPC, we should not see any
   COMMIT RPCs unless they are for dangling WRITEs. so we just pass
   them onto the server.

setattr
 - if size is changed, update size in both attribute and file cache
 - always forward setattr rpc onto the server

can we depend on nfs client to always send an ACCESS rpc before any
read? we don't do access control upon seeing a READ rpc: we just
return data from the cached file. if an user cannot access a file, the
ACCESS rpc will fail, and therefore no READ rpcs will be sent.

is it bad to evict from lrucache a file with an user count greater
than zero?

