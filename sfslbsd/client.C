/* $Id$ */

/*
 *
 * Copyright (C) 1998 David Mazieres (dm@uun.org)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *
 */

#include <stdlib.h>

#include "sha1.h"
#include "serial.h"
#include "sfsrwsd.h"
#include <grp.h>

#include "lbfsdb.h"
#include "fingerprint.h"
#include "lbfs.h"


ihash<const u_int64_t, client, &client::generation, &client::glink> clienttab;

void
client::fail ()
{
  nfssrv = NULL;
  nfscbc = NULL;
}


void
client::nfs3reply (svccb *sbp, void *res, filesrv::reqstate rqs, clnt_stat err)
{
  xdrproc_t xdr = nfs_program_3.tbl[LBFS_PROC_RES_TRANS(sbp->proc ())].xdr_res;

  if (err) {
    xdr_delete (xdr, res);
    sbp->reject (SYSTEM_ERR);
    return;
  }
  doleases (fsrv, generation, rqs.fsno, sbp, res);

  if (fsrv->fixres (sbp, res, &rqs)) {
    nfs3_exp_enable (LBFS_PROC_RES_TRANS(sbp->proc ()), res);
    sbp->reply (res);
    xdr_delete (xdr, res);
  }
  else
    xdr_delete (xdr, res);
}

void
client::renamecb_2 (svccb *sbp, rename3res *rres, filesrv::reqstate rqs,
		    lookup3res *ares, clnt_stat err)
{
  if (!err && !ares->status) {
    xattr xa;
    xa.fh = &ares->resok->object;
    if (ares->resok->obj_attributes.present)
      xa.fattr = reinterpret_cast<ex_fattr3 *>
	(ares->resok->obj_attributes.attributes.addr ());
    dolease (fsrv, 0, static_cast<u_int32_t> (-1), &xa);
  }
  nfs3reply (sbp, rres, rqs, RPC_SUCCESS);
  delete ares;
}

void
client::renamecb_1 (svccb *sbp, void *_res, filesrv::reqstate rqs,
		    clnt_stat err)
{
  rename3res *res = static_cast<rename3res *> (_res);
  AUTH *auth;
  if (err || res->status || !(auth = authtab[sbp->getaui ()])) {
    nfs3reply (sbp, res, rqs, err);
    return;
  }

  lookup3res *ares = New lookup3res;
  fsrv->c->call (NFSPROC3_LOOKUP, &sbp->template getarg<rename3args> ()->to,
		 ares, wrap (mkref (this), &client::renamecb_2,
			     sbp, res, rqs, ares), auth);
}

// returns 0 if sha1 hash of data is equals to the given hash
static inline int
compare_sha1_hash(unsigned char *data, size_t count, sfs_hash &hash)
{
  char h[sha1::hashsize];
  sha1_hash(h, data, count);
  return strncmp(h, hash.base(), sha1::hashsize);
}

void
client::condwrite_got_chunk (svccb *sbp, filesrv::reqstate rqs,
                             lbfs_db::chunk_iterator *iter,
			     unsigned char *data, 
			     size_t count, read3res *, str err)
{
  lbfs_condwrite3args *cwa = sbp->template getarg<lbfs_condwrite3args> ();
  lbfs_chunk_loc c;
  iter->get(&c);

  if (err || count != cwa->count ||
      fingerprint(data, count) != cwa->fingerprint ||
      compare_sha1_hash(data, count, cwa->hash)) {
    if (err) 
      warn << "CONDWRITE: error reading file\n";
    else if (count != cwa->count)
      warn << "CONDWRITE: db corrupted, size does not match\n";
    else if (fingerprint(data,count) != cwa->fingerprint)
      warn << "CONDWRITE: fingerprint mismatch\n";
    else 
      warn << "CONDWRITE: sha1 hash mismatch\n";
    delete[] data;
    // only remove record if it is not an error, so transient 
    // failures won't cause db to be incorrected deleted.
    if (!err)
      iter->del(); 
    if (!iter->next(&c)) { 
      nfs_fh3 fh; 
      c.get_fh(fh); 
      unsigned char *buf = new unsigned char[c.count()];
      nfs3_read
	(fsrv->c, fh, 
	 wrap(mkref(this), &client::condwrite_read_cb, buf, c.pos()), 
	 wrap(mkref(this), &client::condwrite_got_chunk, sbp, rqs, iter, buf), 
	 c.pos(), c.count());
      return; 
    }
  }
 
  else {
    // fingerprint matches, do write
    warn << "CONDWRITE: bingo, found a condwrite candidate\n";
    u_int32_t authno = sbp->getaui ();
    write3args w3arg;
    w3arg.file = cwa->file;
    w3arg.offset = cwa->offset;
    w3arg.count = cwa->count;
    w3arg.stable = UNSTABLE;  // is this correct?
    w3arg.data.set(reinterpret_cast<char*>(data), count, freemode::DELARRAY);
    void *res = nfs_program_3.tbl[NFSPROC3_WRITE].alloc_res ();
    fsrv->c->call (NFSPROC3_WRITE, &w3arg, res,
		   wrap (mkref (this), &client::nfs3reply, sbp, res, rqs),
		   authtab[authno]);
    delete iter;
    return;
  }

  delete iter;
  warn << "CONDWRITE: ran out of files to try\n";
  lbfs_nfs3exp_err (sbp, NFS3ERR_FPRINTNOTFOUND);
}

void
client::condwrite_read_cb(unsigned char *buf, off_t pos0,
                          const unsigned char *data, size_t count, off_t pos)
{
  memmove(buf+(pos-pos0), data, count);
}

void
client::condwrite (svccb *sbp, filesrv::reqstate rqs)
{
  lbfs_condwrite3args *cwa = sbp->template getarg<lbfs_condwrite3args> ();
  lbfs_db::chunk_iterator *iter = 0;
  if (lbfsdb.get_chunk_iterator(cwa->fingerprint, &iter) == 0) {
    if (iter) { 
      lbfs_chunk_loc c; 
      if (!iter->get(&c)) { 
	nfs_fh3 fh; 
	c.get_fh(fh);
	unsigned char *buf = new unsigned char[c.count()];
	nfs3_read
	  (fsrv->c, fh,
	   wrap(mkref(this), &client::condwrite_read_cb, buf, c.pos()), 
	   wrap(mkref(this), &client::condwrite_got_chunk, sbp, rqs, iter, buf),
	   c.pos(), c.count());
	return;
      } 
      delete iter; 
    }
  }
  warn << "CONDWRITE: " << cwa->fingerprint << " not in DB\n";
  lbfs_nfs3exp_err (sbp, NFS3ERR_FPRINTNOTFOUND);
}

void
client::mktmpfile_cb (svccb *sbp, filesrv::reqstate rqs, 
                      void *_cres, clnt_stat err)
{
  diropres3 *cres = static_cast<diropres3 *>(_cres);
  if (err) 
    nfs3reply (sbp, _cres, rqs, RPC_SUCCESS);
  else {
    switch(cres->status) {
      case NFS3ERR_EXIST:
	delete cres;
	mktmpfile(sbp, rqs);
	break;
      default:
	nfs3reply (sbp, _cres, rqs, RPC_SUCCESS);
    }
  }
}

void
client::mktmpfile (svccb *sbp, filesrv::reqstate rqs)
{
  lbfs_mktmpfile3args *mta = sbp->template getarg<lbfs_mktmpfile3args> ();

  str fhstr = armor32(mta->commit_to.data.base(), mta->commit_to.data.size());
  int r = rand();
  str rstr = armor32((void*)&r, sizeof(int));
  char tmpfile[5+fhstr.len()+1+rstr.len()+1];
  sprintf(tmpfile, "sfs.%s.%s", fhstr.cstr(), rstr.cstr());
  warn << "MKTMPFILE: tmp file is " << tmpfile << "\n";
  
  u_int32_t authno = sbp->getaui ();
  create3args c3arg;
  c3arg.where.dir = fsrv->sfs_trash_fhs[rqs.fsno];
  c3arg.where.name = tmpfile;
  c3arg.how.set_mode(GUARDED);
  *(c3arg.how.obj_attributes) = mta->obj_attributes;

  void *cres = nfs_program_3.tbl[NFSPROC3_CREATE].alloc_res ();
  fsrv->c->call (NFSPROC3_CREATE, &c3arg, cres,
		 wrap (mkref (this),
		       &client::mktmpfile_cb, sbp, rqs, cres),
		 authtab[authno]);
}

void
client::committmp_cb (svccb *sbp, filesrv::reqstate rqs, Chunker *chunker,
                      const FATTR3 *attr, commit3res *res, str err)
{
  nfs3reply (sbp, res, rqs, RPC_SUCCESS);
  chunker->stop();
  vec<lbfs_chunk *> *cv = chunker->cvp;
  if (!err) {
    lbfs_committmp3args *cta = sbp->template getarg<lbfs_committmp3args> ();
    for (unsigned i=0; i<cv->size(); i++) {
      (*cv)[i]->loc.set_fh(cta->commit_to);
      (*cv)[i]->loc.set_mtime(attr->mtime);
      lbfsdb.add_chunk((*cv)[i]->fingerprint, &((*cv)[i]->loc)); 
      warn << "COMMITTMP: adding " << (*cv)[i]->fingerprint << " to database\n";
    }
  }
  for (unsigned i=0; i<cv->size(); i++) delete (*cv)[i];
  delete cv;
  delete chunker;
}

void
client::chunk_data 
  (Chunker *chunker, const unsigned char *data, size_t count, off_t)
{
  chunker->chunk(data, count);
}

void
client::committmp (svccb *sbp, filesrv::reqstate rqs)
{
  lbfs_committmp3args *cta = sbp->template getarg<lbfs_committmp3args> ();
  vec<lbfs_chunk *> *v = new vec<lbfs_chunk*>;
  Chunker *chunker = new Chunker(CHUNK_SIZES(0), v);
  nfs3_copy (fsrv->c, cta->commit_from, cta->commit_to,
             wrap(mkref(this), &client::chunk_data, chunker),
             wrap(mkref(this), &client::committmp_cb, sbp, rqs, chunker));
}

void 
client::getfp_cb (svccb *sbp, filesrv::reqstate rqs, Chunker *chunker,
                  size_t count, read3res *rres, str err)
{
  chunker->stop();
  vec<lbfs_chunk *> *cv = chunker->cvp;
  lbfs_getfp3res *res = New lbfs_getfp3res;
  if (!err) {
    unsigned i = 0;
    unsigned n = cv->size() < 1024 ? cv->size() : 1024;
    res->resok->fprints.setsize(n);
    for (; i<n; i++) {
      struct lbfs_fp3 x;
      x.count = (*cv)[i]->loc.count();
      x.fingerprint = (*cv)[i]->fingerprint;
      x.hash = *(chunker->hv[i]);
      res->resok->fprints[i] = x;
      warn << "GETFP: returning " << (*cv)[i]->fingerprint << "\n";
    }
    if (i < cv->size())
      res->resok->eof=false;
    else
      res->resok->eof=true;
    res->resok->file_attributes = rres->resok->file_attributes;
  }
  else {
    res->set_status(rres->status);
    res->resfail = 
      *(union_entry<ex_post_op_attr>*)(&rres->resfail);
    // XXX is this correct
  }
  // XXX - how to make sure nfs3reply does not crash?
  nfs3reply (sbp, res, rqs, RPC_SUCCESS);

  for (unsigned i=0; i<cv->size(); i++) delete (*cv)[i];
  delete cv;
  delete chunker;
}

void
client::getfp (svccb *sbp, filesrv::reqstate rqs)
{
  lbfs_getfp3args *arg = sbp->template getarg<lbfs_getfp3args> ();
  vec<lbfs_chunk *> *v = new vec<lbfs_chunk*>;
  Chunker *chunker = new Chunker(CHUNK_SIZES(0), v, true);
  nfs3_read 
    (fsrv->c, arg->file, 
     wrap(mkref(this), &client::chunk_data, chunker),
     wrap(mkref(this), &client::getfp_cb, sbp, rqs, chunker),
     arg->offset, arg->count);
}

void
client::nfs3dispatch (svccb *sbp)
{
  if (!sbp) {
    fail ();
    return;
  }
  if (sbp->proc () == NFSPROC3_NULL) {
    sbp->reply (NULL);
    return;
  }

  u_int32_t authno = sbp->getaui ();
  if (authno >= authtab.size () || !authtab[authno]) {
    sbp->reject (AUTH_REJECTEDCRED);
    return;
  }
  if (!fsrv) {
    lbfs_nfs3exp_err (sbp, NFS3ERR_BADHANDLE);
    return;
  }

  filesrv::reqstate rqs;
  if (!fsrv->fixarg (sbp, &rqs))
    return;

  if (sbp->proc () == lbfs_NFSPROC3_MKTMPFILE)
    mktmpfile(sbp, rqs);
  else if (sbp->proc () == lbfs_NFSPROC3_COMMITTMP)
    committmp(sbp, rqs);
  else if (sbp->proc () == lbfs_NFSPROC3_CONDWRITE)
    condwrite(sbp, rqs);
  else if (sbp->proc () == lbfs_NFSPROC3_GETFP)
    getfp(sbp, rqs);
  else {
    void *res = nfs_program_3.tbl[sbp->proc ()].alloc_res ();
    if (sbp->proc () == NFSPROC3_RENAME)
      fsrv->c->call (sbp->proc (), sbp->template getarg<void> (), res,
		     wrap (mkref (this), &client::renamecb_1, sbp, res, rqs),
		     authtab[authno]);
    else
      fsrv->c->call (sbp->proc (), sbp->template getarg<void> (), res,
		     wrap (mkref (this), &client::nfs3reply, sbp, res, rqs),
		     authtab[authno]);
  }
}

u_int64_t
client::nextgen ()
{
  static u_int64_t g;
  while (clienttab[++g] || !g)
    ;
  return g;
}

client::client (ref<axprt_crypt> x)
  : sfsserv (x), fsrv (NULL), generation (nextgen ())
{
  nfssrv = asrv::alloc (x, lbfs_program_3,
			wrap (mkref (this), &client::nfs3dispatch));
  nfscbc = aclnt::alloc (x, lbfscb_program_3);
  authtab[0] = authunix_create ("localhost", (uid_t) -1,
				(gid_t) -1, 0, NULL);
  clienttab.insert (this);

  lbfsdb.open();
}

client::~client ()
{
  clienttab.remove (this);
}

void
client::sfs_getfsinfo (svccb *sbp)
{
  if (fsrv)
    sbp->replyref (fsrv->fsinfo);
  else
    sbp->reject (PROC_UNAVAIL);
}

ptr<rabin_priv>
client::doconnect (const sfs_connectarg *ci, sfs_servinfo *si)
{
  fsrv = defsrv;
  *si = fsrv->servinfo;
  return fsrv->sk;
}

void
client_accept (ptr<axprt_crypt> x)
{
  if (!x)
    fatal ("EOF from sfssd\n");
  client::launch (x);
}

