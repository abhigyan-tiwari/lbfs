/*
 *
 * Copyright (C) 2000 Athicha Muthitacharoen (athicha@mit.edu)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *
 */

#include "messages.h"
//#include "fingerprint.h"
#include <xfs/xfs_pioctl.h>
#include "pioctl.h"

u_int64_t cache_entry::nextxh;
ihash<nfs_fh3, cache_entry, &cache_entry::nh,
  &cache_entry::nlink> nfsindex;
ihash<xfs_handle, cache_entry, &cache_entry::xh,
  &cache_entry::xlink> xfsindex;


/* Non-volatile File System Info */
ex_fsinfo3resok fsinfo;

xfs_message_function rcvfuncs[] = {
NULL,						/* version */
(xfs_message_function)xfs_message_wakeup,	/* wakeup */
(xfs_message_function)xfs_message_getroot,	/* getroot */
NULL,						/* installroot */
(xfs_message_function)xfs_message_getnode, 	/* getnode */
NULL,						/* installnode */
(xfs_message_function)xfs_message_getattr,	/* getattr */
NULL,						/* installattr */
(xfs_message_function)xfs_message_getdata,	/* getdata */
NULL,						/* installdata */
(xfs_message_function)xfs_message_inactivenode,	/* inactivenode */
NULL,						/* invalidnode */ 
(xfs_message_function)xfs_message_getdata,	/* open */
(xfs_message_function)xfs_message_putdata,      /* put_data */
(xfs_message_function)xfs_message_putattr,      /* put attr */
(xfs_message_function)xfs_message_create,       /* create */
(xfs_message_function)xfs_message_mkdir,	/* mkdir */
(xfs_message_function)xfs_message_link,		/* link */
(xfs_message_function)xfs_message_symlink,      /* symlink */
(xfs_message_function)xfs_message_remove,	/* remove */
(xfs_message_function)xfs_message_rmdir,	/* rmdir */
(xfs_message_function)xfs_message_rename,	/* rename */
(xfs_message_function)xfs_message_pioctl,	/* pioctl */
#if 0
NULL,	                                        /* wakeup_data */
NULL,						/* updatefid */
NULL,						/* advlock */
NULL						/* gc nodes */
#endif
};

void lbfs_condwrite(ref<condwrite3args> cwa, clnt_stat err);
void normal_read(ref<getfp_args> ga, uint64 offset, uint32 count);
void nfs3_rmdir(int fd, ref<struct xfs_message_rmdir> h, ref<ex_lookup3res> lres,
		clnt_stat err);

void 
reply_err (int fd, u_int seqnum, int err)
{
  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;

  xfs_send_message_wakeup_multiple (fd, seqnum, err, h0, h0_len, NULL, 0);
}

int
xfs_message_wakeup (int fd, ref<struct xfs_message_wakeup> h, u_int size)
{
  warn << "Got xfs_message_wakeup from XFS !!!\n";

  return 0;
}

void 
getrootattr (int fd, ref<struct xfs_message_getroot> h, ref<sfs_fsinfo> fsi,
	     ref<ex_getattr3res > res, time_t rqtime, clnt_stat err)
{

  struct xfs_message_installroot msg;
  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;

  assert (!err && res->status == NFS3_OK);

  warn << "uid = " << getuid () << "\n";

  nfsobj2xfsnode (h->cred, fsi->nfs->v3->root, *res->attributes, rqtime, &msg.node);

  msg.header.opcode = XFS_MSG_INSTALLROOT;
  h0 = (struct xfs_message_header *) &msg;
  h0_len = sizeof (msg);

  xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				    h0, h0_len, NULL, 0);
}

void 
nfs3_fsinfo (int fd, ref<struct xfs_message_getroot> h, ref<sfs_fsinfo> fsi,
	     ref<ex_fsinfo3res > res, clnt_stat err)
{

  assert (!err && res->status == NFS3_OK);

  fsinfo = *res->resok;

  ref<ex_getattr3res > ares = New refcounted < ex_getattr3res >;
  //AUTH *auth_default = authunix_create_default ();

  nfsc->call (lbfs_NFSPROC3_GETATTR, &fsi->nfs->v3->root, ares,
	      wrap (&getrootattr, fd, h, fsi, ares, timenow));
  //         auth_default);  
}

void 
sfs_getfsinfo (int fd, ref<struct xfs_message_getroot> h, ref<sfs_fsinfo> fsi, clnt_stat err)
{

  assert (fsi->prog == ex_NFS_PROGRAM && fsi->nfs->vers == ex_NFS_V3);
  //x->compress ();
  ref<ex_fsinfo3res > res = New refcounted < ex_fsinfo3res >;

  nfsc->call (lbfs_NFSPROC3_FSINFO, &fsi->nfs->v3->root, res,
	      wrap (&nfs3_fsinfo, fd, h, fsi, res));
}

int 
xfs_message_getroot (int fd, ref<struct xfs_message_getroot> h, u_int size)
{
  warn << "get root!!\n";

  ref<sfs_fsinfo> fsi = New refcounted<sfs_fsinfo>;
  sfsc->call (SFSPROC_GETFSINFO, NULL, fsi,
	      wrap (&sfs_getfsinfo, fd, h, fsi), NULL, NULL);

  return 0;
}

void 
nfs3_lookup (int fd, ref<struct xfs_message_getnode> h, uint32 seqnum,
	     ref<ex_lookup3res > lres, time_t rqtime, clnt_stat err)
{

  struct xfs_message_installnode msg;
  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;
  ex_post_op_attr a;

  if (err || lres->status != NFS3_OK) {
    if (err)
      warn << h->header.sequence_num << ":" << err << ":nfs3_lookup\n";
    else {
      warn << h->header.sequence_num << ":" <<strerror(lres->status) << ":nfs3_lookup\n";
      reply_err(fd, seqnum, lres->status);
    }
    return;
  }
  else {
    if (lres->resok->obj_attributes.present)
      a = lres->resok->obj_attributes;
    else if (lres->resok->dir_attributes.present)
      a = lres->resok->dir_attributes;
    else {
      warn << h->header.sequence_num << ":" <<"lookup: error no attr present\n";
      return;
    }
  }

  nfsobj2xfsnode (h->cred, lres->resok->object, *a.attributes, rqtime, &msg.node);

  msg.header.opcode = XFS_MSG_INSTALLNODE;
  msg.parent_handle = h->parent_handle;
  strcpy (msg.name, h->name);
  h0 = (struct xfs_message_header *) &msg;
  h0_len = sizeof (msg);

  xfs_send_message_wakeup_multiple (fd, seqnum, 0,
				    h0, h0_len, NULL, 0);
}

int 
xfs_message_getnode (int fd, ref<struct xfs_message_getnode> h, u_int size)
{
  warn << h->header.sequence_num << ":" <<"get node !! msg.parent_handle ("
    << (int) h->parent_handle.a << ","
    << (int) h->parent_handle.b << ","
    << (int) h->parent_handle.c << ","
    << (int) h->parent_handle.d << ")\n";
  warn << h->header.sequence_num << ":" <<"file name = " << h->name << "\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << h->header.sequence_num << ":" << "xfs_message_getnode: Can't find parent_handle\n";
    return -1;
  }

  diropargs3 doa;
  doa.dir = e->nh;
  doa.name = h->name;
  warn << h->header.sequence_num << ":" << "requesting file name " << doa.name << "\n";
  ref<ex_lookup3res> res = New refcounted<ex_lookup3res>;

  nfsc->call (lbfs_NFSPROC3_LOOKUP, &doa, res,
	      wrap (&nfs3_lookup, fd, h, h->header.sequence_num, res, timenow));

  return 0;
}

void 
write_dirfile (int fd, ref<struct xfs_message_getdata> h, //cache_entry *e, 
	       ref<ex_readdir3res > res, write_dirent_args args, 
	       struct xfs_message_installdata msg,
	       clnt_stat cl_err)
{

  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;

  if (nfsdir2xfsfile (res, &args) < 0) {
    return;
  }

  if (args.last)
    flushbuf (&args);
  free (args.buf);

  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "write_dirfile: Can't find handle ("        
	 << h->handle.a << ","
	 << h->handle.b << ","
	 << h->handle.c << ","
	 << h->handle.d << ")\n";

    return;
  }

  if (!res->resok->reply.eof) {
    readdir3args rda;
    rda.dir = e->nh; 
    entry3 *ent = res->resok->reply.entries;
    while (ent->nextentry != NULL)
      ent = ent->nextentry;
    rda.cookie = ent->cookie;
    rda.cookieverf = res->resok->cookieverf;
    rda.count = fsinfo.dtpref;

    ref<ex_readdir3res > rdres = New refcounted < ex_readdir3res >;
    nfsc->call (lbfs_NFSPROC3_READDIR, &rda, rdres,
		wrap (&write_dirfile, fd, h, rdres, args, msg));
  }
  else {

    close (args.fd);

    e->open = INCACHE;

    msg.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg;
    h0_len = sizeof (msg);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				      h0, h0_len, NULL, 0);

  }
}

void 
nfs3_readdir (int fd, ref<struct xfs_message_getdata> h, cache_entry *e, 
	      ref<ex_readdir3res > res,
	      time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {

    struct xfs_message_installdata msg;
    struct write_dirent_args args;
#if 0
    cache_entry *e = xfsindex[h->handle];
    if (!e) {
      warn << "nfs3_readdir: Can't find node handle\n";
      return;
    }
#endif
    ex_fattr3 attr = *res->resok->dir_attributes.attributes;
    nfsobj2xfsnode (h->cred, e->nh,
		    attr, rqtime, &msg.node);
    e->ltime = max(attr.mtime, attr.ctime);

    msg.node.tokens |= XFS_OPEN_NR | XFS_DATA_R;

    //fill in cache_name, cache_handle, flag
    strcpy (msg.cache_name, e->cache_name);
    args.fd = open (msg.cache_name, O_CREAT | O_RDWR | O_TRUNC, 0666);

    if (args.fd < 0) {
      return;
    }

    fhandle_t cfh;
    if (getfh (msg.cache_name, &cfh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg.cache_handle, &cfh, sizeof (cfh));
    write_dirfile (fd, h, res, args, msg, clnt_stat (0));

  }
  else {
    if (err)
      warn << "nfs3_readdir: " << err << "\n";
    else {
      warn << "nfs3_readdir: " << strerror (errno) << "(" << errno << ")\n";
      reply_err (fd, h->header.sequence_num, res->status);
    }
  }
}

void 
write_file (ref<getfp_args> ga, uint64 offset, uint32 count,
	    ref<ex_read3res > res)
{

  warn << "filename = " << ga->out_fname << " offset = " << offset << "\n";
  int out_fd = open (ga->out_fname, O_CREAT | O_WRONLY, 0666);
  if (out_fd < 0) {
    warn << "write_file1: " << ga->out_fname << " " << strerror (errno) << "\n";
    return;
  }

  int err;
  if ((err = lseek (out_fd, offset, SEEK_SET)) < 0) {
    warn << "write_file2: " << ga->out_fname << " " << strerror (errno) << "\n";
    return;
  }

  if ((err = write (out_fd, res->resok->data.base (), res->resok->data.size ())) < 0) {
    warn << "write_file3: " << ga->out_fname << " " << strerror (errno) << "\n";
    return;
  }
  else if (err != (int) res->resok->data.size ()) {
    warn << "write error or short write!!\n";
    return;
  }
  close (out_fd);

  if (res->resok->count < count)
    normal_read (ga, offset + res->resok->count, count - res->resok->count);
  else
    ga->blocks_written++;
}

void 
nfs3_read (ref<getfp_args> ga, uint64 offset, uint32 count,
	   ref<ex_read3res > res, clnt_stat err)
{
  if (!err && res->status == NFS3_OK) {
    assert (res->resok->file_attributes.present);

    write_file (ga, offset, count, res);

    if (ga->blocks_written == ga->total_blocks && ga->eof) {

      cache_entry *e = xfsindex[ga->h->handle];
      if (!e) {
	warn << "nfs3_read: Can't find node handle\n";
	return;
      }

      //add chunk to the database
      vec < lbfs_chunk * >cvp;
      if (chunk_file (CHUNK_SIZES (0), &cvp, (char const *) ga->msg.cache_name) < 0) {
	warn << strerror (errno) << "(" << errno << "): nfs3_read(chunkfile)\n";
	return;
      }
      for (uint i = 0; i < cvp.size (); i++) {
	warn << "adding fp = " << cvp[i]->fingerprint << " to lbfsdb\n";
	cvp[i]->loc.set_fh (e->nh);
	lbfsdb.add_entry (cvp[i]->fingerprint, &(cvp[i]->loc));
        delete cvp[i];
      }
      lbfsdb.sync ();
      e->cache_name = ga->msg.cache_name;
      e->open = INCACHE;

      struct xfs_message_header *h0 = NULL;
      size_t h0_len = 0;

      ga->msg.header.opcode = XFS_MSG_INSTALLDATA;
      h0 = (struct xfs_message_header *) &(ga->msg);
      h0_len = sizeof (ga->msg);

      xfs_send_message_wakeup_multiple (ga->fd, ga->h->header.sequence_num, 0,
					h0, h0_len, NULL, 0);
    }
  }
  else {
    if (err)
      warn << "nfs3_read: " << err << "\n";
    else {
      warn << "nfs3_read: " << strerror (res->status) << "\n";
      reply_err (ga->fd, ga->h->header.sequence_num, res->status);
    }
  }
}

void 
normal_read (ref<getfp_args> ga, uint64 offset, uint32 count)
{
  cache_entry *e = xfsindex[ga->h->handle];
  if (!e) {
    warn << "normal_read: Can't find node handle\n";
    return;
  }

  read3args ra;
  ra.file = e->nh;
  ra.offset = offset;
  ra.count = count;

  ref<ex_read3res > rres = New refcounted < ex_read3res >;
  nfsc->call (lbfs_NFSPROC3_READ, &ra, rres,
	      wrap (&nfs3_read, ga, offset, count, rres));
}

void 
compose_file (ref<getfp_args> ga, ref<lbfs_getfp3res > res)
{

  int err, chfd, out_fd;
  uint64 offset = ga->offset;	//chunk position
  fp_db::iterator * ci = NULL;
  bool found = false;
  nfs_fh3 fh;
  lbfs_chunk_loc c;
  cache_entry *e = NULL;

  for (uint i = 0; i < res->resok->fprints.size (); i++) {
    found = false;
    unsigned char buf[res->resok->fprints[i].count];
    //find matching fp in the database
    //if found, write that chunk to the file,
    //otherwise, send for a normal read of that chunk
    if (!lbfsdb.get_iterator (res->resok->fprints[i].fingerprint, &ci)) {
      if (!ci)
	warn << "ci is NULL\n";
      if (ci && !(ci->get (&c))) {
	do {
	  found = true;
	  c.get_fh (fh);

	  if (c.count () != res->resok->fprints[i].count) {
	    warn << "chunk size != size from server..\n";
	    found = false;
	  }
	  else {
	    //read chunk c.pos() to c.count() from fh into buf 
	    e = nfsindex[fh];
	    if (!e) {
	      warn << "compose_file: null fh or Can't find node handle\n";
	      return;
	    }
	    warn << "reading chunks from " << e->cache_name << "\n";
	    chfd = open (e->cache_name, O_RDONLY, 0666);
	    if (chfd < 0) {
	      warn << "compose_file: error: " << strerror (errno) << "(" << errno << ")\n";
	      return;
	    }
	    if (lseek (chfd, c.pos (), SEEK_SET) < 0) {
	      warn << "compose_file: error: " << strerror (errno) << "(" << errno << ")\n";
	      return;
	    }
	    if ((err = read (chfd, buf, c.count ())) > -1) {
	      if ((uint32) err != c.count ()) {
		warn << "compose_file: error: " << err << " != " << c.count () << "\n";
		return;
	      }
	      if (compare_sha1_hash (buf, c.count (),
				     res->resok->fprints[i].hash)) {
		warn << "compose_file: sha1 hash mismatch\n";
		//warn << buf << "\n";
		found = false;
	      }
	    }
	    else {
	      warn << "compose_file: error: " << strerror (errno) << "(" << errno << ")\n";
	      return;
	    }
	    close (chfd);
	  }

	  if (found) {
	    warn << "FOUND!! compose_file: fp = " << res->resok->fprints[i].fingerprint << " in client DB\n";
	    out_fd = open (ga->out_fname, O_CREAT | O_WRONLY, 0666);
	    if (out_fd < 0) {
	      warn << "compose_file: " << strerror (errno) << "\n";
	      return;
	    }

	    //write that chunk to the file
	    if (lseek (out_fd, offset, SEEK_SET) < 0) {
	      warn << "compose_file: error: " << strerror (errno) << "(" << errno << ")\n";
	      return;
	    }
	    if ((err = write (out_fd, buf, c.count ())) > -1) {
	      if ((uint32) err != c.count ()) {
		warn << "compose_file: error: " << err << " != " << c.count () << "\n";
		return;
	      }
	    }
	    else {
	      warn << "compose_file: error: " << strerror (errno) << "(" << errno << ")\n";
	      return;
	    }
	    close (out_fd);
	    ga->blocks_written++;
	  }
	} while (!found && !(ci->next (&c)));
      }
      delete ci;
    }
    if (!found) {
      warn << "compose_file: fp = " << res->resok->fprints[i].fingerprint << " not in DB\n";
      normal_read (ga, offset, res->resok->fprints[i].count);
    }
    offset += res->resok->fprints[i].count;
  }
  ga->offset = offset;		//offset is 'the' current position in the file

  if (ga->blocks_written == ga->total_blocks && ga->eof) {
    e = xfsindex[ga->h->handle];
    if (!e) {
      warn << "compose_file: Can't find node handle\n";
      return;      
    }
    e->cache_name = ga->msg.cache_name;
    e->open = INCACHE;

    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;

    ga->msg.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &(ga->msg);
    h0_len = sizeof (ga->msg);

    xfs_send_message_wakeup_multiple (ga->fd, ga->h->header.sequence_num, 0,
				      h0, h0_len, NULL, 0);
  }
}

void 
lbfs_getfp (ref<getfp_args> ga, ref<lbfs_getfp3res > res, time_t rqtime,
	    clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {
    cache_entry *e = xfsindex[ga->h->handle];
    if (!e) {
      warn << "lbfs_getfp: Can't find node handle (" 
	   << ga->h->handle.a << ","
	   << ga->h->handle.b << ","
	   << ga->h->handle.c << ","
	   << ga->h->handle.d << ")\n";
      return;
    }

    ex_fattr3 attr = *(res->resok->file_attributes.attributes);
    attr.expire += rqtime;
    e->nfs_attr = attr;
    e->ltime = max(attr.mtime, attr.ctime);

    ga->total_blocks += res->resok->fprints.size ();
    ga->eof = res->resok->eof;
    compose_file (ga, res);

    if (!res->resok->eof) {
      //ga->offset += gfp->count; //ga->res->resok->count;
      lbfs_getfp3args gfp;
      gfp.file = e->nh;
      gfp.offset = ga->offset;
      gfp.count = LBFS_MAXDATA;

      ref<lbfs_getfp3res > fpres = New refcounted < lbfs_getfp3res >;
      //ga->res = fpres;
      nfsc->call (lbfs_GETFP, &gfp, fpres,
		  wrap (&lbfs_getfp, ga, fpres, timenow));
    }
  }
  else {
    warn << "lbfs_getfp: " << strerror (res->status) << "\n";
    reply_err (ga->fd, ga->h->header.sequence_num, res->status);
  }
}

void 
nfs3_read_exist (int fd, ref<struct xfs_message_getdata> h, cache_entry *e)
{

  struct xfs_message_installdata msg;

  nfsobj2xfsnode (h->cred, e->nh,
		  e->nfs_attr, 0, &msg.node);

  msg.node.tokens |= XFS_OPEN_NR | XFS_DATA_R
    | XFS_OPEN_NW | XFS_DATA_W;	//This line is a hack...need to get read access 

  strcpy (msg.cache_name, e->cache_name);
  fhandle_t cfh;
  if (getfh (msg.cache_name, &cfh)) {
    warn << "getfh failed\n";
    return;
  }
  memmove (&msg.cache_handle, &cfh, sizeof (cfh));

  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;

  msg.header.opcode = XFS_MSG_INSTALLDATA;
  h0 = (struct xfs_message_header *) &msg;
  h0_len = sizeof (msg);

  xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				    h0, h0_len, NULL, 0);

}

void 
getfp (int fd, ref<struct xfs_message_getdata> h, cache_entry *e)
{

  struct xfs_message_installdata msg;

  //this is to fill in msg.node only
  nfsobj2xfsnode (h->cred, e->nh,
		  e->nfs_attr, 0, &msg.node);

  msg.node.tokens |= XFS_OPEN_NR | XFS_DATA_R
    | XFS_OPEN_NW | XFS_DATA_W;	//This line is a hack...need to get read access 

  str fhstr = armor32(e->nh.data.base(), e->nh.data.size());
  int r = rand();
  str rstr = armor32((void*)&r, sizeof(int));
  //char *newcache = New char[5+fhstr.len()+1+rstr.len()+1];
  str newcache = strbuf("cache/%02X/sfslbcd.%s.%s", 
			e->xh.a >> 8, fhstr.cstr(), rstr.cstr());

  //nfs_fh3 new_fh = nfs_fh3();
  //cache_entry *new_e = new cache_entry(new_fh, e->nfs_attr);
  //strcpy (msg.cache_name, new_e->cache_name);
  strcpy (msg.cache_name, newcache);
  int cfd = open (msg.cache_name, O_CREAT | O_WRONLY | O_TRUNC, 0666);
  if (cfd < 0) {
    warn << "xfs_message_getdata: " << strerror (errno) << "\n";
    return;
  }
  close (cfd);

  fhandle_t cfh;
  if (getfh (msg.cache_name, &cfh)) {
    warn << "getfh failed\n";
    return;
  }
  memmove (&msg.cache_handle, &cfh, sizeof (cfh));

  ref<getfp_args> ga = New refcounted<getfp_args> (fd, h);
  ga->msg = msg;
  strcpy (ga->out_fname, msg.cache_name);

  lbfs_getfp3args gfp;
  gfp.file = e->nh;
  gfp.offset = 0;
  gfp.count = LBFS_MAXDATA;

  ref<lbfs_getfp3res > fpres = New refcounted < lbfs_getfp3res >;

  nfsc->call (lbfs_GETFP, &gfp, fpres,
	      wrap (&lbfs_getfp, ga, fpres, timenow));
}

bool 
greater (nfstime3 a, nfstime3 b)
{
  if (a.seconds > b.seconds)
    return true;
  else if (a.seconds == b.seconds &&
	   a.nseconds > b.nseconds)
    return true;
  else
    return false;
}

void 
comp_time (int fd, ref<struct xfs_message_getdata> h, bool dirfile,
	   ptr < ex_getattr3res > res, time_t rqtime, clnt_stat err)
{
  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "comp_time: Can't find node handle\n";
    return;
  }

  if (res != NULL) {
    if (!err && res->status == NFS3_OK) {
      ex_fattr3 attr = *(res->attributes);
      attr.expire += rqtime;
      e->nfs_attr = attr;
    } else {
      if (err) 
	warn << "comp_time: " << err << "\n";
      else {
	warn << "comp_time: " << strerror(res->status) << "\n";
      }
    }
  }

  nfstime3 maxtime = max(e->nfs_attr.mtime, e->nfs_attr.ctime);
  if (greater (maxtime, e->ltime)) {
    if (dirfile) {
#if 0      
      if (!e) {
	warn << "comp_time: Can't find node handle\n";
	return;
      }
#endif
      readdir3args rda;
      rda.dir = e->nh;
      rda.cookie = 0;
      rda.cookieverf = cookieverf3 ();
      rda.count = fsinfo.dtpref;

      ref<ex_readdir3res > rdres = New refcounted < ex_readdir3res >;
      nfsc->call (lbfs_NFSPROC3_READDIR, &rda, rdres,
		  wrap (&nfs3_readdir, fd, h, e, rdres, timenow));
    }
    else
      getfp (fd, h, e);
  }
  else
    nfs3_read_exist (fd, h, e);
}

void 
nfs3_readlink (int fd, ref<struct xfs_message_getdata> h, cache_entry *e,
	       ref<ex_readlink3res > res,
	       time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {

    struct xfs_message_installdata msg;
    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
#if 0
    cache_entry *e = xfsindex[h->handle];
    if (!e) {
      warn << "nfs3_readlink: Can't find node handle\n";
      return;
    }
#endif
    ex_fattr3 attr = *res->resok->symlink_attributes.attributes;
    nfsobj2xfsnode (h->cred, e->nh,
		    attr, rqtime, &msg.node);
    e->ltime = max(attr.mtime, attr.ctime);

    msg.node.tokens |= XFS_OPEN_NR | XFS_DATA_R
      | XFS_OPEN_NW | XFS_DATA_W;	//This line is a hack...need to get read access 

    strcpy (msg.cache_name, e->cache_name);

    int lfd = open (msg.cache_name, O_CREAT | O_WRONLY | O_TRUNC, 0666);
    if (lfd < 0)
      return;

    fhandle_t cfh;
    if (getfh (msg.cache_name, &cfh)) {
      warn << "getfh failed\n";
      return;
    }

    memmove (&msg.cache_handle, &cfh, sizeof (cfh));
    write (lfd, res->resok->data.cstr (), res->resok->data.len ());
    close (lfd);
    e->open = INCACHE;

    msg.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg;
    h0_len = sizeof (msg);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				      h0, h0_len, NULL, 0);
  } else {
    if (err) 
      warn << "nfs3_readlink: " << err << "\n";
    else {
      warn << "nfs3_readlink: " << strerror(res->status) << "\n";
    }
  }
}

int 
xfs_message_getdata (int fd, ref<struct xfs_message_getdata> h, u_int size)
{

  warn << "get data !! msg.handle ("
    << (int) h->handle.a << ","
    << (int) h->handle.b << ","
    << (int) h->handle.c << ","
    << (int) h->handle.d << ")\n";

  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "xfs_message_getdata: Can't find node handle\n";
    return -1;
  }

  if (e->open == XFS_OPEN_NW || e->open == XFS_OPEN_EW) {
    nfs3_read_exist (fd, h, e);
    return 0;
  }

  if (e->nfs_attr.type == NF3LNK) {
    warn << "reading a symlink!!\n";
    nfs_fh3 fh = e->nh;
    ref<ex_readlink3res > rlres = New refcounted < ex_readlink3res >;
    nfsc->call (lbfs_NFSPROC3_READLINK, &fh, rlres,
		wrap (&nfs3_readlink, fd, h, e, rlres, timenow));
    return 0;
  }

  if (!e->open) {
    e->open = h->tokens & XFS_OPEN_MASK;
    if (e->nfs_attr.type == NF3DIR) {
      readdir3args rda;
      rda.dir = e->nh;
      rda.cookie = 0;
      rda.cookieverf = cookieverf3 ();
      rda.count = fsinfo.dtpref;

      ref<ex_readdir3res > rdres = New refcounted < ex_readdir3res >;
      nfsc->call (lbfs_NFSPROC3_READDIR, &rda, rdres,
		  wrap (&nfs3_readdir, fd, h, e, rdres, timenow));
    }
    else 
      if (e->nfs_attr.type == NF3REG)
	getfp (fd, h, e);
  }
  else {
    if (e->nfs_attr.expire < (uint32) timenow) {
      nfs_fh3 fh = e->nh;
      ptr < ex_getattr3res > res = New refcounted < ex_getattr3res >;
      nfsc->call (lbfs_NFSPROC3_GETATTR, &fh, res,
		  wrap (&comp_time, fd, h,
			e->nfs_attr.type == NF3DIR, res, timenow));
    }
    else
      comp_time (fd, h, e->nfs_attr.type == NF3DIR, NULL, 0, clnt_stat (0));
  }
  return 0;
}

void 
nfs3_getattr (int fd, ref<struct xfs_message_getattr> h, cache_entry *e,
	      ref<ex_getattr3res > res, time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {

  struct xfs_message_installattr msg;
  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;

  nfsobj2xfsnode (h->cred, e->nh, *res->attributes, rqtime, &msg.node);

  msg.header.opcode = XFS_MSG_INSTALLATTR;
  h0 = (struct xfs_message_header *) &msg;
  h0_len = sizeof (msg);

  xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				    h0, h0_len, NULL, 0);
  } else {
    if (err) 
      warn << "nfs3_getattr: " << err << "\n";
    else {
      warn << "nfs3_getattr: " << strerror(res->status) << "\n";
    }
  }
}

int 
xfs_message_getattr (int fd, ref<struct xfs_message_getattr> h, u_int size)
{
  warn << "get attr !!\n";
  warn << "msg.handle ("
    << (int) h->handle.a << ","
    << (int) h->handle.b << ","
    << (int) h->handle.c << ","
    << (int) h->handle.d << ")\n";

  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "xfs_getattr: Can't find node handle\n";
    return -1;
  }

  nfs_fh3 fh = e->nh;
  ref<ex_getattr3res > res = New refcounted < ex_getattr3res >;
  nfsc->call (lbfs_NFSPROC3_GETATTR, &fh, res,
	      wrap (&nfs3_getattr, fd, h, e, res, timenow));

  return 0;
}

void 
committmp (ref<condwrite3args > cwa, ref<ex_commit3res > res, time_t rqtime,
	   clnt_stat err)
{
  if (!err && res->status == NFS3_OK) {

    cache_entry *e = xfsindex[cwa->h->handle];
    if (!e) {
      warn << "committmp: Can't find node handle(" 
	   << cwa->h->handle.a << ","
	   << cwa->h->handle.b << ","
	   << cwa->h->handle.c << ","
	   << cwa->h->handle.d << ")\n";

      return;
    }
    ex_fattr3 attr = *(res->resok->file_wcc.after.attributes);
    attr.expire += rqtime;
    e->nfs_attr = attr;
    e->ltime = max(attr.mtime, attr.ctime);
    xfs_send_message_wakeup (cwa->fd, cwa->h->header.sequence_num, 0);
  }
  else {
    if (err) 
      warn << "nfs3_committmp: " << err << "\n";
    else {
      warn << "nfs3_committmp: " << strerror (res->status) << "\n";
      reply_err (cwa->fd, cwa->h->header.sequence_num, res->status);
    }
  }
}

void 
sendcommittmp (ref<condwrite3args > cwa)
{

  //signal the server to commit the tmp file
  lbfs_committmp3args ct;
  ct.commit_from = cwa->tmpfh;
  
  cache_entry *e = xfsindex[cwa->h->handle];  
  if (!e) {
    warn << "xfs_getattr: Can't find node handle\n";
    return;
  }
  ct.commit_to = e->nh;

  ref<ex_commit3res > cres = New refcounted < ex_commit3res >;
  nfsc->call (lbfs_COMMITTMP, &ct, cres,
	      wrap (&committmp, cwa, cres, timenow));
}

void 
nfs3_write (ref<condwrite3args > cwa, ref<ex_write3res > res, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {
    cwa->blocks_written++;
    if ( /*cwa->done && */ cwa->blocks_written == cwa->total_blocks)
      sendcommittmp (cwa);
  }
  else {
    if (err) 
      warn << "nfs3_write: " << err << "\n";
    else {
      warn << "nfs3_write: error: " << strerror (res->status) << "\n";
      reply_err (cwa->fd, cwa->h->header.sequence_num, res->status);
    }
  }
}

void 
sendwrite (ref<condwrite3args > cwa, lbfs_chunk * chunk)
{
  int err, ost;
  char iobuf[NFS_MAXDATA];
  uint64 offst = chunk->loc.pos ();
  uint32 count = chunk->loc.count ();

  int rfd = open (cwa->fname, O_RDONLY, 0666);
  if (rfd < 0) {
    warn << "sendwrite: " << strerror (errno) << "\n";
    return;
  }

  while (count > 0) {
    ost = lseek (rfd, offst, SEEK_SET);
    if (count < NFS_MAXDATA)
      err = read (rfd, iobuf, count);
    else
      err = read (rfd, iobuf, NFS_MAXDATA);
    count -= err;
    offst += err;
    if (err < 0) {
      warn << "lbfs_condwrite: error: " << strerror (errno) << "(" << errno << ")\n";
      return;
    }
    write3args wa;
    wa.file = cwa->tmpfh;
    wa.offset = ost;
    wa.stable = UNSTABLE;
    wa.count = err;
    wa.data.setsize (err);
    memcpy (wa.data.base (), iobuf, err);

    ref<ex_write3res > res = New refcounted < ex_write3res >;
    nfsc->call (lbfs_NFSPROC3_WRITE, &wa, res,
		wrap (&nfs3_write, cwa, res));
  }
  close (rfd);
}

void 
lbfs_sendcondwrite (ref<condwrite3args > cwa, lbfs_chunk * chunk,
		    ref<ex_write3res > res, clnt_stat err)
{
  if (!err && res->status == NFS3_OK) {
    if (res->resok->count != chunk->loc.count ()) {
      warn << "lbfs_sendcondwrite: did not write the whole chunk...\n";
      return;
    }
    cwa->blocks_written++;
    if ( /*cwa->done && */ cwa->blocks_written == cwa->total_blocks)
      sendcommittmp (cwa);
  }
  else {
    if (err) 
      warn << "lbfs_sendcondwrite: " << err << "\n";
    else {
      if (res->status == NFS3ERR_FPRINTNOTFOUND)
	sendwrite (cwa, chunk);
      else {
	warn << "lbfs_sendcondwrite: " << strerror (res->status) << "\n";
	reply_err (cwa->fd, cwa->h->header.sequence_num, res->status);
      }
    }
  }
}

void 
sendcondwrite (ref<condwrite3args > cwa, lbfs_chunk * chunk)
{

  lbfs_condwrite3args cw;
  cw.file = cwa->tmpfh;
  cw.offset = chunk->loc.pos ();
  cw.count = chunk->loc.count ();
  cw.fingerprint = chunk->fingerprint;

  int rfd = open (cwa->fname, O_RDONLY, 0666);
  if (rfd < 0) {
    warn << "sendcondwrite: " << cwa->fname << ".." << strerror (errno) << "\n";
    return;
  }

  lseek (rfd, chunk->loc.pos (), SEEK_SET);
  char buf[cw.count];
  int err = read (rfd, buf, cw.count);
  if (err < 0) {
    warn << "lbfs_condwrite: error: " << strerror (errno) << "(" << errno << ")\n";
    return;
  }
  else if (uint (err) != cw.count) {
    warn << "reading: chunk size " << cw.count << " got " << err << "\n";
    return;
  }
  sha1_hash (&cw.hash, buf, err);
  close (rfd);

  ref<ex_write3res > res = New refcounted < ex_write3res >;

  nfsc->call (lbfs_CONDWRITE, &cw, res,
	      wrap (&lbfs_sendcondwrite, cwa, chunk, res));
}

void 
lbfs_mktmpfile (int fd, ref<struct xfs_message_putdata> h,
		ref<ex_diropres3 > res, clnt_stat err)
{
  if (err) {
    warn << "lbfs_mktmpfile: " << err << "\n";
    return;
  }
  else {
    if (res->status != NFS3_OK) {
      warn << "lbfs_mktmpfile: error: " << strerror (res->status) << "(" << res->status << ")\n";
      reply_err (fd, h->header.sequence_num, res->status);
      return;
    }
    else if (!res->resok->obj.present) {
      warn << "tmpfile handle not present\n";
      return;
    }
  }
  //send data to server
  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "xfs_getattr: Can't find node handle\n";
    return;
  }

  ref<condwrite3args > cwa = New refcounted < condwrite3args > (fd, h,
						   *res->resok->obj.handle);
  strcpy (cwa->fname, e->cache_name);

  int data_fd = open (cwa->fname, O_RDONLY, 0666);
  if (data_fd < 0) {
    warn << "lbfs_mktmpfile: " << strerror (errno) << "\n";
    return;
  }
  cwa->chunker = New Chunker(CHUNK_SIZES(0));
  uint count, index = 0, v_size = 0;
  unsigned char buf[4096];
  while ((count = read(data_fd, buf, 4096)) > 0) {
    cwa->chunker->chunk(buf, count);
    if (cwa->chunker->chunk_vector().size() > v_size) {
      //send condwrite request on last_index..size()
      v_size = cwa->chunker->chunk_vector().size();
      cwa->total_blocks = v_size;
      warn << "chindex = " << index << " size = " << v_size << "\n";
      sendcondwrite(cwa, cwa->chunker->chunk_vector()[index++]);
    }
  }
  cwa->chunker->stop();
  close(data_fd);
  cwa->done = true;
  cwa->total_blocks = cwa->chunker->chunk_vector().size();
  warn << "blocks written = " << cwa->blocks_written
    << " total_blocks = " << cwa->total_blocks << "\n";
  if (index + 1 != cwa->total_blocks) {
    warn << "lbfs_mktmpfile: index = " << index << " total = " << cwa->total_blocks
      << "still more chunks!!!\n";
  }
  for (uint i=index; i<cwa->total_blocks; i++) {
    warn << "chindex = " << i << " size = " <<  cwa->total_blocks<< "\n";
    sendcondwrite(cwa, cwa->chunker->chunk_vector()[i]);    
  }
}

int 
xfs_message_putdata (int fd, ref<struct xfs_message_putdata> h, u_int size)
{

  warn << "putdata !!\n";

  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "xfs_putdata: Can't find node handle\n";
    return -1;
  }

  //get temp file handle so the update will be atomic
  lbfs_mktmpfile3args mt;
  mt.commit_to = e->nh;
  xfsattr2nfsattr (h->header.opcode, h->attr, &mt.obj_attributes);

  ref<ex_diropres3 > res = New refcounted < ex_diropres3 >;

  nfsc->call (lbfs_MKTMPFILE, &mt, res,
	      wrap (&lbfs_mktmpfile, fd, h, res));

  return 0;
}

int 
xfs_message_inactivenode (int fd, ref<struct xfs_message_inactivenode> h, u_int size)
{

  warn << "inactivenode !!(" 
       << h->handle.a << ","
       << h->handle.b << ","
       << h->handle.c << ","
       << h->handle.d << ")\n";
  //remove node from cache
  if (h->flag == XFS_DELETE ||	//Node is no longer in kernel cache. Delete immediately!!
       h->flag == XFS_NOREFS) {	//Node is still in kernel cache. Delete when convenient.
    cache_entry *e = xfsindex[h->handle];
    if (e) {
      e->inactive = true;
#if 0 //keep everything for now
      delete e;
#endif 
    }
  }
  //  xfs_send_message_wakeup (fd, h->header.sequence_num, 0);

  return 0;

}

void 
nfs3_setattr (int fd, ref<struct xfs_message_putattr> h, ref<ex_wccstat3 > res,
	      time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {

    assert (res->wcc->after.present);

    struct xfs_message_installattr msg;
    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;

    cache_entry *e = xfsindex[h->handle];
    if (!e) {
      warn << "nfs3_setattr: Can't find node handle\n";
      return;
    }
    nfsobj2xfsnode (h->cred, e->nh,
		    *res->wcc->after.attributes, rqtime, &msg.node);

    msg.header.opcode = XFS_MSG_INSTALLATTR;
    h0 = (struct xfs_message_header *) &msg;
    h0_len = sizeof (msg);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				      h0, h0_len, NULL, 0);

  }
  else {
    if (err)
      warn << err << ": nfs3_setattr\n";
    else
      warn << strerror (res->status) << ": nfs3_setattr\n";
    reply_err (fd, h->header.sequence_num, res->status);
  }
}

int 
xfs_message_putattr (int fd, ref<struct xfs_message_putattr> h, u_int size)
{

  warn << "putattr !!\n";

  cache_entry *e = xfsindex[h->handle];
  if (!e) {
    warn << "xfs_message_putattr: Can't find node handle\n";
    return -1;
  }

  setattr3args sa;
  sa.object = e->nh;
  xfsattr2nfsattr (h->header.opcode, h->attr, &sa.new_attributes);
  sa.guard.set_check (false);
#if 0
  if (sa->guard.check)
    sa.guard.ctime->seconds = h->attr.xa_ctime;
#endif
  ref<ex_wccstat3 > res = New refcounted < ex_wccstat3 >;
  nfsc->call (lbfs_NFSPROC3_SETATTR, &sa, res,
	      wrap (&nfs3_setattr, fd, h, res, timenow));

  return 0;
}

void 
nfs3_create (int fd, ref<struct xfs_message_create> h, ref<ex_diropres3 > res,
	     time_t rqtime, clnt_stat err)
{
  
  if (!err && res->status == NFS3_OK) {
 
    struct xfs_message_installdata msg1;	//change content of parent dir
    
    struct xfs_message_installnode msg2;	//New file node
    
    struct xfs_message_installdata msg3;	//New file content (null)
    
    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct xfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct xfs_message_header *h2 = NULL;
    size_t h2_len = 0;

    assert (res->resok->obj.present && res->resok->obj_attributes.present);
    //create new file
    nfsobj2xfsnode (h->cred, *(res->resok->obj.handle),
	      *(res->resok->obj_attributes.attributes), rqtime, &msg2.node);

    cache_entry *e1 = nfsindex[*(res->resok->obj.handle)];
    if (!e1) {
      warn << "nfs3_create: Can't find node handle\n";
      return;
    }
    
    strcpy (msg3.cache_name, e1->cache_name);
    int new_fd = open (msg3.cache_name, O_CREAT | O_RDWR | O_TRUNC, 0666);
    
    if (new_fd < 0) {
      warn << "nfs3_create: " << strerror (errno) << "\n";
      return;
    }
    close (new_fd);

    fhandle_t new_fh;
    if (getfh (msg3.cache_name, &new_fh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg3.cache_handle, &new_fh, sizeof (new_fh));

    //write new direntry to parent dirfile (do a readdir or just append that entry?)
    cache_entry *e2 = xfsindex[h->parent_handle];
    if (!e2) {
      warn << "nfs3_create: Can't find parent handle\n";
      return;
    }
    
    strcpy (msg1.cache_name, e2->cache_name);
#if 0
    int dir_fd = open (msg1.cache_name, O_CREAT | O_RDWR | O_APPEND, 0666);
    if (nfsdirent2xfsfile (dir_fd, h->name, (*res->resok->obj_attributes.attributes).fileid) < 0)
      return;
    close (dir_fd);
#endif
    //msg1.node.tokens = same as parent dir's

    assert (res->resok->dir_wcc.after.present);
    
    nfsobj2xfsnode (h->cred, e2->nh,
		    *(res->resok->dir_wcc.after.attributes), rqtime, &msg1.node);
    
    msg1.flag = 0;
    msg1.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg1;
    h0_len = sizeof (msg1);
    
    msg2.node.tokens = XFS_ATTR_R
      | XFS_OPEN_NW | XFS_OPEN_NR
      | XFS_DATA_R | XFS_DATA_W;	//override nfsobj2xfsnode?
    
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof (msg2.name));
    
    msg2.header.opcode = XFS_MSG_INSTALLNODE;
    h1 = (struct xfs_message_header *) &msg2;
    h1_len = sizeof (msg2);
    
    msg3.node = msg2.node;
    msg3.flag = 0;
    msg3.header.opcode = XFS_MSG_INSTALLDATA;
    
    h2 = (struct xfs_message_header *) &msg3;
    h2_len = sizeof (msg3);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num,
				      0, h0, h0_len, h1, h1_len, h2, h2_len,
				      NULL, 0);

  }
  else {
    if (err)
      warn << err << ": nfs3_create\n";
    else {
      warn << strerror (res->status) << ": nfs3_create\n";
      reply_err (fd, h->header.sequence_num, res->status);
    }
  }
}

int 
xfs_message_create (int fd, ref<struct xfs_message_create> h, u_int size)
{

  warn << "create !!\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << "xfs_message_create: Can't find parent_handle\n";
    return -1;
  }

  create3args ca;
  ca.where.dir = e->nh;
  ca.where.name = h->name;
  ca.how.set_mode (GUARDED);
  if (ca.how.mode == UNCHECKED || ca.how.mode == GUARDED)
    xfsattr2nfsattr (h->header.opcode, h->attr, &(*ca.how.obj_attributes));
  else
    warn << "xfs_message_create: create mode not UNCHECKED or GUARDED\n";

  ref<ex_diropres3 > res = New refcounted < ex_diropres3 >;
  nfsc->call (lbfs_NFSPROC3_CREATE, &ca, res,
	      wrap (&nfs3_create, fd, h, res, timenow));

  return 0;
}

void 
nfs3_mkdir (int fd, ref<struct xfs_message_mkdir> h, ref<ex_diropres3 > res,
	    time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {

    struct xfs_message_installdata msg1;	//change content of parent dir

    struct xfs_message_installnode msg2;	//new dir node

    struct xfs_message_installdata msg3;	//new dir content (null)

    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct xfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct xfs_message_header *h2 = NULL;
    size_t h2_len = 0;

    assert (res->resok->obj.present && res->resok->obj_attributes.present);
    //create new dirfile
    nfsobj2xfsnode (h->cred, *(res->resok->obj.handle),
	      *(res->resok->obj_attributes.attributes), rqtime, &msg2.node);

    cache_entry *e1 = nfsindex[*(res->resok->obj.handle)];
    if (!e1) {
      warn << "nfs3_mkdir: Can't find node handle\n";
      return;
    }

    strcpy (msg3.cache_name, e1->cache_name);
    int new_fd = open (msg3.cache_name, O_CREAT, 0666);

    if (new_fd < 0) {
      warn << "nfs3_mkdir: " << errno << " " << strerror (errno) << "\n";
      return;
    }
    close (new_fd);

    fhandle_t new_fh;
    if (getfh (msg3.cache_name, &new_fh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg3.cache_handle, &new_fh, sizeof (new_fh));

    //write new direntry to parent dirfile (do a readdir or just append that entry?)
    cache_entry *e2 = xfsindex[h->parent_handle];
    if (!e2) {
      warn << "nfs3_mkdir: Can't find parent handle\n";
      return;
    }

    strcpy (msg1.cache_name, e2->cache_name);
#if 0
    int dir_fd = open (msg1.cache_name, O_WRONLY | O_APPEND, 0666);
    if (nfsdirent2xfsfile (dir_fd, h->name, (*res->resok->obj_attributes.attributes).fileid) < 0)
      return;
    close (dir_fd);
#endif
    fhandle_t parent_fh;
    if (getfh (msg1.cache_name, &parent_fh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg1.cache_handle, &parent_fh, sizeof (parent_fh));

    //msg1.node.tokens = same as parent dir's

    assert (res->resok->dir_wcc.after.present);

    nfsobj2xfsnode (h->cred, e2->nh,
	       *(res->resok->dir_wcc.after.attributes), rqtime, &msg1.node);

    msg1.flag = 0;
    msg1.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg1;
    h0_len = sizeof (msg1);

    //msg2.node.tokens = same as parent dir's
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof (msg2.name));

    msg2.header.opcode = XFS_MSG_INSTALLNODE;
    h1 = (struct xfs_message_header *) &msg2;
    h1_len = sizeof (msg2);

    msg3.node = msg2.node;
    msg3.flag = 0;
    msg3.header.opcode = XFS_MSG_INSTALLDATA;

    h2 = (struct xfs_message_header *) &msg3;
    h2_len = sizeof (msg3);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num,
				      0, h0, h0_len, h1, h1_len, h2, h2_len,
				      NULL, 0);
  }
  else {
    if (err)
      warn << err << ": nfs3_mkdir\n";
    else {
      warn << strerror (res->status) << ": nfs3_mkdir\n";
      reply_err (fd, h->header.sequence_num, res->status);
    }
  }
}

int 
xfs_message_mkdir (int fd, ref<struct xfs_message_mkdir> h, u_int size)
{

  warn << "mkdir !!\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << "xfs_message_mkdir: Can't find parent_handle\n";
    return -1;
  }

  mkdir3args ma;
  ma.where.dir = e->nh;
  ma.where.name = h->name;
  xfsattr2nfsattr (h->header.opcode, h->attr, &ma.attributes);

  ref<ex_diropres3 > res = New refcounted < ex_diropres3 >;
  nfsc->call (lbfs_NFSPROC3_MKDIR, &ma, res,
	      wrap (&nfs3_mkdir, fd, h, res, timenow));

  return 0;
}

void 
nfs3_link (int fd, ref<struct xfs_message_link> h, ref<ex_link3res > res,
	   time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {
    struct xfs_message_installdata msg1;	//update parent dir's data
    
    struct xfs_message_installnode msg2;	//update attr of from_handle

    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct xfs_message_header *h1 = NULL;
    size_t h1_len = 0;

    //change attributes of parent dir
    //in the future implement local content change too..
    cache_entry *e1 = xfsindex[h->parent_handle];
    if (!e1) {
      warn << "xfs_message_link: Can't find parent_handle\n";
      return;
    }
    strcpy (msg1.cache_name, e1->cache_name);
    
    fhandle_t parent_fh;
    if (getfh (msg1.cache_name, &parent_fh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg1.cache_handle, &parent_fh, sizeof (parent_fh));
    
    assert (res->res->linkdir_wcc.after.present);
    nfsobj2xfsnode (h->cred, e1->nh,
		    *(res->res->linkdir_wcc.after.attributes), rqtime, &msg1.node);
    
    msg1.flag = 0;
    msg1.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg1;
    h0_len = sizeof (msg1);
    
    cache_entry *e2 = xfsindex[h->from_handle];
    if (!e2) {
      warn << "xfs_message_link: Can't find from_handle\n";
      return;
    }

    assert (res->res->file_attributes.present);
    nfsobj2xfsnode (h->cred, e2->nh,
		    *(res->res->file_attributes.attributes), rqtime, &msg2.node);
    
    msg2.node.tokens = XFS_ATTR_R;
    msg2.parent_handle = h->parent_handle;
    strcpy (msg2.name, h->name);

    msg2.header.opcode = XFS_MSG_INSTALLNODE;
    h1 = (struct xfs_message_header *) &msg2;
    h1_len = sizeof (msg2);
    
    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num, 0,
				      h0, h0_len, h1, h1_len, NULL, 0);
  } else {
    if (err)
      warn << err << ": nfs3_link\n";
    else {
      warn << strerror (res->status) << ": nfs3_link\n";
      reply_err (fd, h->header.sequence_num, res->status);
    }
  }
}

int 
xfs_message_link (int fd, ref<struct xfs_message_link> h, u_int size)
{

  warn << "(hard) link !!\n";

  cache_entry *e1 = xfsindex[h->from_handle];
  if (!e1) {
    warn << "xfs_message_link: Can't find from_handle\n";
    return -1;
  }
  link3args la;
  la.file = e1->nh;

  cache_entry *e2 = xfsindex[h->parent_handle];
  if (!e2) {
    warn << "xfs_message_link: Can't find parent_handle\n";
    return -1;
  }
  la.link.dir = e2->nh;
  la.link.name = h->name;

  ref<ex_link3res > res = New refcounted < ex_link3res >;
  nfsc->call (lbfs_NFSPROC3_LINK, &la, res,
	      wrap (&nfs3_link, fd, h, res, timenow));

  return 0;
}

void 
nfs3_symlink (int fd, ref<struct xfs_message_symlink> h, cache_entry *e, 
	      ref<ex_diropres3 > res, time_t rqtime, clnt_stat err)
{

  if (!err && res->status == NFS3_OK) {
    struct xfs_message_installdata msg1;	//install change in parent dir

    struct xfs_message_installnode msg2;	//install symlink node

    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct xfs_message_header *h1 = NULL;
    size_t h1_len = 0;

    assert (res->resok->obj.present && res->resok->obj_attributes.present);
    //create symlink
    ex_fattr3 attr = *res->resok->obj_attributes.attributes;
    nfsobj2xfsnode (h->cred, *(res->resok->obj.handle),
		    attr, rqtime, &msg2.node);
    e->ltime = max(attr.mtime, attr.ctime);

    //write new direntry to parent dirfile (do a readdir or just append that entry?)
    cache_entry *e = xfsindex[h->parent_handle];
    if (!e) {
      warn << "nfs3_symlink: Can't find parent handle\n";
      return;
    }
    strcpy (msg1.cache_name, e->cache_name);

    //add entry to parent dir (changing the mtime)
    assert (res->resok->dir_wcc.after.present);

    nfsobj2xfsnode (h->cred, e->nh,
	       *(res->resok->dir_wcc.after.attributes), rqtime, &msg1.node);

    msg1.flag = 0;
    msg1.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg1;
    h0_len = sizeof (msg1);

    msg2.node.tokens = XFS_ATTR_R;
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof (msg2.name));

    msg2.header.opcode = XFS_MSG_INSTALLNODE;
    h1 = (struct xfs_message_header *) &msg2;
    h1_len = sizeof (msg2);

    xfs_send_message_wakeup_multiple (fd, h->header.sequence_num,
				      0, h0, h0_len, h1, h1_len, NULL, 0);

  }
  else {
    if (err)
      warn << err << ": nfs3_symlink\n";
    else {
      warn << "nfs3_symlink: " << strerror (res->status) << "\n";
      reply_err (fd, h->header.sequence_num, res->status);
    }
  }
}

int 
xfs_message_symlink (int fd, ref<struct xfs_message_symlink> h, u_int size)
{

  warn << "symlimk !!\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << "xfs_message_symlink: Can't find parent_handle\n";
    return -1;
  }

  symlink3args sla;
  sla.where.dir = e->nh;
  sla.where.name = h->name;
  xfsattr2nfsattr (h->header.opcode, h->attr, &(sla.symlink.symlink_attributes));
  sla.symlink.symlink_data.setbuf (h->contents, strlen (h->contents));

  ref<ex_diropres3 > res = New refcounted < ex_diropres3 >;
  nfsc->call (lbfs_NFSPROC3_SYMLINK, &sla, res,
	      wrap (&nfs3_symlink, fd, h, e, res, timenow));

  return 0;
}

void 
remove (int fd, ref<struct xfs_message_remove> h, ref<ex_lookup3res > lres,
	ref<ex_wccstat3 > wres, time_t rqtime, clnt_stat err)
{

  //remove entry from parent dir
  cache_entry *e1 = xfsindex[h->parent_handle];
  if (!e1) {
    warn << "xfs_message_remove: Can't find parent_handle\n";
    return;
  }
  if (!err && wres->status == NFS3_OK) {

    assert (wres->wcc->after.present);

    struct xfs_message_installdata msg1;
    struct xfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct xfs_message_installattr msg2;
    struct xfs_message_header *h1 = NULL;
    size_t h1_len = 0;
#if 0
    //remove entry from parent dir
    cache_entry *e1 = xfsindex[h->parent_handle];
    if (!e1) {
      warn << "xfs_message_remove: Can't find parent_handle\n";
      return;
    }
#endif
    strcpy (msg1.cache_name, e1->cache_name);
    fhandle_t cfh;
    if (getfh (msg1.cache_name, &cfh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg1.cache_handle, &cfh, sizeof (cfh));
    //remove entry from local dir after..
#if 0
    int dir_fd = open (msg1.cache_name, O_RDWR | O_SHLOCK, 0666);
    if (xfsfile_rm_dirent (dir_fd, h->name) < 0)
      return;
    close (dir_fd);
#endif
    ex_fattr3 attr = *(wres->wcc->after.attributes);
    nfsobj2xfsnode (h->cred, e1->nh,
		    attr, rqtime, &msg1.node);

    msg1.flag = XFS_ID_INVALID_DNLC;
    msg1.node.tokens |= XFS_DATA_R;

    msg1.header.opcode = XFS_MSG_INSTALLDATA;
    h0 = (struct xfs_message_header *) &msg1;
    h0_len = sizeof (msg1);

    //if the entry being removed from parent is still being referenced (nlink > 1)
    //update its attr, otherwise, evict from cache

    ex_post_op_attr a;
    if (lres->resok->obj_attributes.present)
      a = lres->resok->obj_attributes;
    else if (lres->resok->dir_attributes.present)
      a = lres->resok->dir_attributes;
    else {
      warn << "lookup in remove: error no attr present\n";
      return;
    }

    if ((a.attributes->type == NF3DIR && a.attributes->nlink > 2) ||
	(a.attributes->type == NF3REG && a.attributes->nlink > 1)) {

      cache_entry *e2 = nfsindex[lres->resok->object];
      if (!e2) {
	warn << "xfs_message_remove: Can't find handle\n";
	return;
      }

      msg2.header.opcode = XFS_MSG_INSTALLATTR;
      --(a.attributes->nlink);
      nfsobj2xfsnode (h->cred, e2->nh,
		      *(a.attributes), rqtime, &msg1.node);

      //msg2.node.tokens   = limbo_entry->tokens;

      //  if data is not being used in the kernel...
      //  msg2.node.tokens &= ~XFS_DATA_MASK;

      h1 = (struct xfs_message_header *) &msg2;
      h1_len = sizeof (msg2);


      xfs_send_message_wakeup_multiple (fd, h->header.sequence_num,
					0, h0, h0_len, h1, h1_len,
					NULL, 0);

    }
    else {
      //TODO: evict from cache..or save?
      xfs_send_message_wakeup_multiple (fd, h->header.sequence_num,
					0, h0, h0_len, NULL, 0);
    }

  }
  else {
#if 0
    if (wres->status == NFS3ERR_ISDIR) {
      diropargs3 doa;
      doa.dir = e1->nh;
      doa.name = h->name;
      
      ref<ex_wccstat3 > rmdres = New refcounted < ex_wccstat3 >;
      nfsc->call (lbfs_NFSPROC3_RMDIR, &doa, rmdres,
		  wrap (&remove, fd, (struct xfs_message_remove *) h, lres, rmdres, timenow));      
    } else
#endif 
    if (err)
      warn << err << ": nfs3_lookup in remove\n";
    else {
      warn << strerror (wres->status) << ": nfs3_lookup in remove\n";
      reply_err (fd, h->header.sequence_num, wres->status);
    }
  }
}

void 
nfs3_remove (int fd, ref<struct xfs_message_remove> h, ref<ex_lookup3res > lres,
	     clnt_stat err)
{

  if (!err && lres->status == NFS3_OK) {

    //lookup entry's filehandle and attr
    //if the entry being removed from parent is still being referenced (nlink > 1)
    //update its attr

    cache_entry *e = xfsindex[h->parent_handle];
    if (!e) {
      warn << "xfs_message_mkdir: Can't find parent_handle\n";
      return;
    }

    diropargs3 doa;
    doa.dir = e->nh;
    doa.name = h->name;

    ref<ex_wccstat3 > wres = New refcounted < ex_wccstat3 >;
    nfsc->call (lbfs_NFSPROC3_REMOVE, &doa, wres,
		wrap (&remove, fd, h, lres, wres, timenow));

  }
  else {
    if (err)
      warn << err << ": nfs3_remove\n";
    else {
      warn << "nfs3_remove: lres->status = " << strerror (lres->status) << "\n";
      reply_err (fd, h->header.sequence_num, lres->status);
    }
  }
}

int 
xfs_message_remove (int fd, ref<struct xfs_message_remove> h, u_int size)
{

  warn << "remove !!\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << "xfs_message_mkdir: Can't find parent_handle\n";
    return -1;
  }

  diropargs3 doa;
  doa.dir = e->nh;
  doa.name = h->name;
  warn << "requesting file name " << doa.name.cstr () << "\n";
  ref<ex_lookup3res > res = New refcounted < ex_lookup3res >;

  nfsc->call (lbfs_NFSPROC3_LOOKUP, &doa, res,
	      wrap (&nfs3_remove, fd, h, res));

  return 0;
}

void 
nfs3_rmdir (int fd, ref<struct xfs_message_rmdir> h, ref<ex_lookup3res > lres,
	    clnt_stat err)
{

  if (!err && lres->status == NFS3_OK) {

    //lookup entry's filehandle and attr
    //if the entry being removed from parent is still being referenced (nlink > 1)
    //update its attr

    cache_entry *e = xfsindex[h->parent_handle];
    if (!e) {
      warn << "xfs_message_mkdir: Can't find parent_handle\n";
      return;
    }

    diropargs3 doa;
    doa.dir = e->nh;
    doa.name = h->name;

    ref<struct xfs_message_remove> hr = New refcounted<struct xfs_message_remove>;
    hr->header = h->header;
    hr->parent_handle = h->parent_handle;
    hr->name = h->name;
    hr->cred = h->cred;

    ref<ex_wccstat3 > wres = New refcounted < ex_wccstat3 >;
    nfsc->call (lbfs_NFSPROC3_RMDIR, &doa, wres,
		wrap (&remove, fd, /*(struct xfs_message_remove *)*/ hr, lres, wres, timenow));

  }
  else {
    if (err)
      warn << err << ": nfs3_rmdir\n";
    else {
      warn << "nfs3_rmdir: lres->status = " << lres->status << "\n";
      reply_err (fd, h->header.sequence_num, lres->status);
    }
  }
}

int 
xfs_message_rmdir (int fd, ref<struct xfs_message_rmdir> h, u_int size)
{

  warn << "rmdir !!\n";

  cache_entry *e = xfsindex[h->parent_handle];
  if (!e) {
    warn << "xfs_message_mkdir: Can't find parent_handle\n";
    return -1;
  }

  diropargs3 doa;
  doa.dir = e->nh;
  doa.name = h->name;
  warn << "requesting file name " << doa.name.cstr () << "\n";
  ref<ex_lookup3res > res = New refcounted < ex_lookup3res >;

  nfsc->call (lbfs_NFSPROC3_LOOKUP, &doa, res,
	      wrap (&nfs3_rmdir, fd, h, res));

  return 0;
}

void 
update_attr (cache_entry *e, ex_fattr3 attr1, ex_fattr3 attr2, 
	     time_t rqtime1, time_t rqtime2)
{

  nfstime3 cache_time = e->ltime;
  if (greater (attr1.mtime, cache_time) || greater (attr1.ctime, cache_time)) {
    attr1.expire += rqtime1;
    e->nfs_attr = attr1;
  }
  else if (greater (attr2.mtime, attr1.mtime)) {
    attr2.expire += rqtime2;
    e->nfs_attr = attr2;
  }
  else {
    e->ltime = max(attr2.mtime, attr2.ctime);
    attr2.expire += rqtime2;
    e->nfs_attr = attr2;
  }
}

void 
nfs3_rename_getattr (ref<rename_args> rena, time_t rqtime2, clnt_stat err)
{


  if (err || rena->gares->status != NFS3_OK) {
    if (err)
      warn << err << ": nfs3_rename_getattr\n";
    else {
      warn << "nfs3_rename_getattr: gares->status = " << strerror (rena->gares->status) << "\n";
      reply_err (rena->fd, rena->h->header.sequence_num, rena->gares->status);
    }
    return;
  }

  struct xfs_message_installnode msg1;	//update attr of file renamed 

  struct xfs_message_installdata msg2;	//new parent dir content

  struct xfs_message_installdata msg3;	//old parent dir content

  struct xfs_message_header *h0 = NULL;
  size_t h0_len = 0;
  struct xfs_message_header *h1 = NULL;
  size_t h1_len = 0;
  struct xfs_message_header *h2 = NULL;
  size_t h2_len = 0;
  nfs_fh3 file = rena->lres->resok->object;

  cache_entry *e1 = nfsindex[file];
  if (!e1) {
    warn << "nfs3_rename_getattr: Can't find file handle\n";
    return;
  }

  if (rena->lres->resok->obj_attributes.present)
    update_attr (e1, *(rena->lres->resok->obj_attributes.attributes),
		 *(rena->gares->attributes), rena->rqtime1, rqtime2);
  else if (rena->lres->resok->dir_attributes.present)
    update_attr (e1, *(rena->lres->resok->dir_attributes.attributes),
		 *(rena->gares->attributes), rena->rqtime1, rqtime2);

  nfsobj2xfsnode (rena->h->cred, file, e1->nfs_attr, 0, &msg1.node);

  msg1.parent_handle = rena->h->new_parent_handle;
  strlcpy (msg1.name, rena->h->new_name, sizeof (msg1.name));

  msg1.header.opcode = XFS_MSG_INSTALLNODE;
  h0 = (struct xfs_message_header *) &msg1;
  h0_len = sizeof (msg1);

  cache_entry *e2 = xfsindex[rena->h->new_parent_handle];
  if (!e2) {
    warn << "nfs3_rename_getattr: Can't find file new_parent_handle(" 
	 << rena->h->new_parent_handle.a << ","
	 << rena->h->new_parent_handle.b << ","
	 << rena->h->new_parent_handle.c << ","
	 << rena->h->new_parent_handle.d << ")\n";
    return;
  }
  strcpy (msg2.cache_name, e2->cache_name);
  //change content of new parent dir (later)
  fhandle_t parent_fh;
  if (getfh (msg2.cache_name, &parent_fh)) {
    warn << "getfh failed\n";
    return;
  }
  memmove (&msg2.cache_handle, &parent_fh, sizeof (parent_fh));
  assert (rena->rnres->res->todir_wcc.after.present);
  nfsobj2xfsnode (rena->h->cred, e2->nh,
		  *(rena->rnres->res->todir_wcc.after.attributes),
		  rqtime2, &msg2.node);

  msg2.flag = 0;
  msg2.header.opcode = XFS_MSG_INSTALLDATA;
  h1 = (struct xfs_message_header *) &msg2;
  h1_len = sizeof (msg2);

  if (!xfs_handle_eq (&rena->h->old_parent_handle, &rena->h->new_parent_handle)) {
    cache_entry *e3 = xfsindex[rena->h->old_parent_handle];
    if (!e3) {
      warn << "nfs3_rename_getattr: Can't find file old_parent_handle\n";
      return;
    }
    strcpy (msg3.cache_name, e3->cache_name);
    //change content of new parent dir (later)
    if (getfh (msg3.cache_name, &parent_fh)) {
      warn << "getfh failed\n";
      return;
    }
    memmove (&msg3.cache_handle, &parent_fh, sizeof (parent_fh));
    assert (rena->rnres->res->fromdir_wcc.after.present);
    nfsobj2xfsnode (rena->h->cred, e3->nh,
		    *(rena->rnres->res->fromdir_wcc.after.attributes),
		    rqtime2, &msg3.node);

    msg3.flag = 0;
    msg3.header.opcode = XFS_MSG_INSTALLDATA;
    h2 = (struct xfs_message_header *) &msg3;
    h2_len = sizeof (msg3);
  }

  xfs_send_message_wakeup_multiple (rena->fd, rena->h->header.sequence_num,
				    0, h0, h0_len, h1, h1_len, h2, h2_len,
				    NULL, 0);
}

void 
nfs3_rename_rename (ref<rename_args> rena, clnt_stat err)
{

  warn << "rename_rename !!\n";
  if (!err) {
    nfs_fh3 fh = rena->lres->resok->object;
    //rena->gares = New refcounted<ex_getattr3res>;
    
    nfsc->call (lbfs_NFSPROC3_GETATTR, &fh, rena->gares,
		wrap (&nfs3_rename_getattr, rena, timenow));
  } else {
    if (err)
      warn << err << ": nfs3_rename_rename\n";
  }
}

void 
nfs3_rename_lookup (ref<rename_args> rena, time_t rqtime, clnt_stat err)
{

  warn << "rename_lookup !!\n";

  if (err || rena->lres->status != NFS3_OK) {
    if (err)
      warn << err << ": nfs3_rename_lookup\n";
    else {
      warn << "nfs3_rename_lookup: lres->status = " << strerror (rena->lres->status) << "\n";
      reply_err (rena->fd, rena->h->header.sequence_num, rena->lres->status);
    }
    return;
  }

  cache_entry *e1 = xfsindex[rena->h->old_parent_handle];
  if (!e1) {
    warn << "xfs_message_rename: Can't find old_parent_handle\n";
    return;
  }

  rename3args rna;
  rna.from.dir = e1->nh;
  rna.from.name = rena->h->old_name;

  cache_entry *e2 = xfsindex[rena->h->new_parent_handle];
  if (!e2) {
    warn << "xfs_message_rename: Can't find new_parent_handle\n";
    return;
  }

  rna.to.dir = e2->nh;
  rna.to.name = rena->h->new_name;

  rena->rqtime1 = rqtime;
  //rena->rnres = New refcounted<ex_rename3res>;

  nfsc->call (lbfs_NFSPROC3_RENAME, &rna, rena->rnres,
	      wrap (&nfs3_rename_rename, rena));
}

int 
xfs_message_rename (int fd, ref<struct xfs_message_rename> h, u_int size)
{

  warn << "rename !!\n";

  cache_entry *e = xfsindex[h->old_parent_handle];
  if (!e) {
    warn << "xfs_message_rename: Can't find old_parent_handle\n";
    return -1;
  }

  diropargs3 doa;
  doa.dir = e->nh;
  doa.name = h->old_name;

  ref<rename_args> rena = New refcounted<rename_args> (fd, h);
  //rena->lres = New ex_lookup3res;
  nfsc->call (lbfs_NFSPROC3_LOOKUP, &doa, rena->lres,
	      wrap (&nfs3_rename_lookup, rena, timenow));
  return 0;
}

int
xfs_message_pioctl (int fd, ref<struct xfs_message_pioctl> h, u_int size) {
  
  warn << "pioctl!! return 0 no matter what!!!\n";

  warn << "pioctl: opcode = " << h->opcode << "\n";
  
  int error = 0;

  switch(h->opcode) {
#ifdef KERBEROS
#ifdef VIOCSETTOK_32
  case VIOCSETTOK_32:
  case VIOCSETTOK_64:
#else
  case VIOCSETTOK:
#endif
    error = viocsettok (fd, h, size);
    break;
#ifdef VIOCGETTOK_32
  case VIOCGETTOK_32:
  case VIOCGETTOK_64:
#else
  case VIOCGETTOK :
#endif
    return viocgettok (fd, h, size);
#ifdef VIOCUNPAG_32
  case VIOCUNPAG_32:
  case VIOCUNPAG_64:
#else
  case VIOCUNPAG:
#endif
#ifdef VIOCUNLOG_32
  case VIOCUNLOG_32:
  case VIOCUNLOG_64:
#else
  case VIOCUNLOG:
#endif
    error = viocunlog (fd, h, size);
    break;
#endif /* KERBEROS */
#ifdef VIOCCONNECTMODE_32
  case VIOCCONNECTMODE_32:
  case VIOCCONNECTMODE_64:
#else
  case VIOCCONNECTMODE:
#endif
    return viocconnect(fd, h, size);
#ifdef VIOCFLUSH_32
  case VIOCFLUSH_32:
  case VIOCFLUSH_64:
#else
  case VIOCFLUSH:
#endif
    error = viocflush(fd, h, size);
    break;
#ifdef VIOC_FLUSHVOLUME_32
  case VIOC_FLUSHVOLUME_32:
  case VIOC_FLUSHVOLUME_64:
#else
  case VIOC_FLUSHVOLUME:
#endif
    error = viocflushvolume(fd, h, size);
    break;
#ifdef VIOCGETFID_32
  case VIOCGETFID_32:
  case VIOCGETFID_64:
#else
  case VIOCGETFID:
#endif
    return viocgetfid (fd, h, size);
#ifdef VIOCGETAL_32
  case VIOCGETAL_32:
  case VIOCGETAL_64:
#else
  case VIOCGETAL:
#endif
    return viocgetacl(fd, h, size);
#ifdef VIOCSETAL_32
  case VIOCSETAL_32:
  case VIOCSETAL_64:
#else
  case VIOCSETAL:
#endif
    return viocsetacl(fd, h, size);
#ifdef VIOCGETVOLSTAT_32
  case VIOCGETVOLSTAT_32:
  case VIOCGETVOLSTAT_64:
#else
  case VIOCGETVOLSTAT:
#endif
    return viocgetvolstat(fd, h, size);
#ifdef VIOCSETVOLSTAT_32
  case VIOCSETVOLSTAT_32:
  case VIOCSETVOLSTAT_64:
#else
  case VIOCSETVOLSTAT:
#endif
    error = viocsetvolstat(fd, h, size);
    break;
#ifdef VIOC_AFS_STAT_MT_PT_32
  case VIOC_AFS_STAT_MT_PT_32:
  case VIOC_AFS_STAT_MT_PT_64:
#else
  case VIOC_AFS_STAT_MT_PT:
#endif
    return vioc_afs_stat_mt_pt(fd, h, size);
#ifdef VIOC_AFS_DELETE_MT_PT_32
  case VIOC_AFS_DELETE_MT_PT_32:
  case VIOC_AFS_DELETE_MT_PT_64:
#else
  case VIOC_AFS_DELETE_MT_PT:
#endif
    return vioc_afs_delete_mt_pt(fd, h, size);
#ifdef VIOCWHEREIS_32
  case VIOCWHEREIS_32:
  case VIOCWHEREIS_64:
#else
  case VIOCWHEREIS:
#endif
    return viocwhereis(fd, h, size);
#ifdef VIOCNOP_32
  case VIOCNOP_32:
  case VIOCNOP_64:
#else
  case VIOCNOP:
#endif
    error = EINVAL;
    break;
#ifdef VIOCGETCELL_32
  case VIOCGETCELL_32:
  case VIOCGETCELL_64:
#else
  case VIOCGETCELL:
#endif
    return vioc_get_cell(fd, h, size);
#ifdef VIOC_GETCELLSTATUS_32
  case VIOC_GETCELLSTATUS_32:
  case VIOC_GETCELLSTATUS_64:
#else
  case VIOC_GETCELLSTATUS:
#endif
    return vioc_get_cellstatus(fd, h, size);
#ifdef VIOC_SETCELLSTATUS_32
  case VIOC_SETCELLSTATUS_32:
  case VIOC_SETCELLSTATUS_64:
#else
  case VIOC_SETCELLSTATUS:
#endif
    return vioc_set_cellstatus(fd, h, size);
#ifdef VIOCNEWCELL_32
  case VIOCNEWCELL_32:
  case VIOCNEWCELL_64:
#else
  case VIOCNEWCELL:
#endif
    return vioc_new_cell(fd, h, size);
#ifdef VIOC_VENUSLOG_32
  case VIOC_VENUSLOG_32:
  case VIOC_VENUSLOG_64:
#else
    case VIOC_VENUSLOG:
#endif
	error = viocvenuslog (fd, h, size);
	break;
#ifdef VIOC_AFS_SYSNAME_32
    case VIOC_AFS_SYSNAME_32:
    case VIOC_AFS_SYSNAME_64:
#else
    case VIOC_AFS_SYSNAME:
#endif
	return vioc_afs_sysname (fd, h, size);
#ifdef VIOC_FILE_CELL_NAME_32
    case VIOC_FILE_CELL_NAME_32:
    case VIOC_FILE_CELL_NAME_64:
#else
    case VIOC_FILE_CELL_NAME:
#endif
	return viocfilecellname (fd, h, size);
#ifdef VIOC_GET_WS_CELL_32
    case VIOC_GET_WS_CELL_32:
    case VIOC_GET_WS_CELL_64:
#else
    case VIOC_GET_WS_CELL:
#endif
	return viocgetwscell (fd, h, size);
#ifdef VIOCSETCACHESIZE_32
    case VIOCSETCACHESIZE_32:
    case VIOCSETCACHESIZE_64:
#else
    case VIOCSETCACHESIZE:
#endif
	error = viocsetcachesize (fd, h, size);
	break;
#ifdef VIOCCKSERV_32
    case VIOCCKSERV_32:
    case VIOCCKSERV_64:
#else
    case VIOCCKSERV:
#endif
	return viocckserv (fd, h, size);
#ifdef VIOCGETCACHEPARAMS_32
    case VIOCGETCACHEPARAMS_32:
    case VIOCGETCACHEPARAMS_64:
#else
    case VIOCGETCACHEPARAMS:
#endif
	return viocgetcacheparms (fd, h, size);
#ifdef VIOC_GETRXKCRYPT_32
    case VIOC_GETRXKCRYPT_32:
    case VIOC_GETRXKCRYPT_64:
#else
    case VIOC_GETRXKCRYPT:
#endif
	return getrxkcrypt(fd, h, size);
#ifdef VIOC_SETRXKCRYPT_32
    case VIOC_SETRXKCRYPT_32:
    case VIOC_SETRXKCRYPT_64:
#else
    case VIOC_SETRXKCRYPT:
#endif
	error = setrxkcrypt(fd, h, size);
	break;
#ifdef VIOC_FPRIOSTATUS_32
    case VIOC_FPRIOSTATUS_32:
    case VIOC_FPRIOSTATUS_64:
#else
    case VIOC_FPRIOSTATUS:
#endif
	error = vioc_fpriostatus(fd, h, size);
	break;
#ifdef VIOC_AVIATOR_32
    case VIOC_AVIATOR_32:
    case VIOC_AVIATOR_64:
#else
    case VIOC_AVIATOR:
#endif
	return viocaviator (fd, h, size);
#ifdef VIOC_ARLADEBUG_32
    case VIOC_ARLADEBUG_32:
    case VIOC_ARLADEBUG_64:
#else
    case VIOC_ARLADEBUG:
#endif
	return vioc_arladebug (fd, h, size);
#ifdef VIOC_GCPAGS_32
    case VIOC_GCPAGS_32:
    case VIOC_GCPAGS_64:
#else
    case VIOC_GCPAGS:
#endif
	error = vioc_gcpags (fd, h, size);
	break;
#ifdef VIOC_CALCULATE_CACHE_32
    case VIOC_CALCULATE_CACHE_32:
    case VIOC_CALCULATE_CACHE_64:
#else
    case VIOC_CALCULATE_CACHE:
#endif
	return vioc_calculate_cache (fd, h, size);
#ifdef VIOC_BREAKCALLBACK_32
    case VIOC_BREAKCALLBACK_32:
    case VIOC_BREAKCALLBACK_64:
#else
    case VIOC_BREAKCALLBACK:
#endif	
	error = vioc_breakcallback (fd, h, size);
	break;
    default:
      warn << "unknown pioctl call \n";
      error = EINVAL ;
  }

  xfs_send_message_wakeup (fd, h->header.sequence_num, error);
    
  return 0;

}

void 
cbdispatch (svccb * sbp)
{
  if (!sbp)
    return;

  switch (sbp->proc ()) {
  case ex_NFSCBPROC3_NULL:
    sbp->reply (NULL);
    break;
  case ex_NFSCBPROC3_INVALIDATE:
    {
      ex_invalidate3args *xa = sbp->template getarg < ex_invalidate3args > ();
      ex_fattr3 *a = NULL;
      if (xa->attributes.present && xa->attributes.attributes->expire) {
	a = xa->attributes.attributes.addr ();
	a->expire += timenow;
	cache_entry *e = nfsindex[xa->handle];
	if (!e) {
	  warn << "cbdispatch: Can't find handle\n";
	  return;
	}
	e->nfs_attr = *a;
      }
      //delete a; should we delete this?
      sbp->reply (NULL);
      break;
    }
  default:
    sbp->reject (PROC_UNAVAIL);
    break;
  }
}
